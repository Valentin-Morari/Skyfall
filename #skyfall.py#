#!/usr/bin/env python

import pygame,random,sys


black    = (   0,   0,   0)
white    = ( 255, 255, 255)
green    = (   0, 255,   0, 255)
red      = ( 255,   0,   0, 255)
blue     = (   0,   0, 255)
skyblue  = ( 96, 164, 208)
 
pygame.init()
  
size = [630,600]
screen = pygame.display.set_mode(size, pygame.NOFRAME)
 
pygame.display.set_caption("S K Y F A L L")

FPS=60

pygame.mixer.pre_init(26700, -16,2, 48000)

done = False
 
clock = pygame.time.Clock()
time_counter = pygame.time.Clock()


# Image load!


player_img = pygame.image.load("Player.png").convert()


player_img.set_colorkey(white)

time_player_img=pygame.image.load("Time_Player.png").convert()
time_player_img.set_colorkey(white)

grass_img=pygame.image.load("Grass.png").convert()
grass2_img=pygame.image.load("Grass2.png").convert()
walk_img=pygame.image.load("walk.png").convert()
run_img=pygame.image.load("run.png").convert()
weak_img=pygame.image.load("weak.png").convert()
strong_img=pygame.image.load("STRONG.PNG").convert()

skullfront_img=pygame.image.load("skullfront.png").convert()
skullfront_img.set_colorkey(black)
skullback_img=pygame.image.load("skullback.png").convert()
skullback_img.set_colorkey(black)

skill_select_img=pygame.image.load("selector.png").convert()
skill_select_img.set_colorkey(white)
definer_img=pygame.image.load("definer.png").convert()
definer_img.set_colorkey(white)
hp_img=pygame.image.load("hp.png").convert()
hp_img.set_colorkey(white)
nohp_img=pygame.image.load("nohp.png").convert()

dexbuff_img=pygame.image.load("dexbuff.png").convert()
dexbuff_img.set_colorkey(white)
hpbuff_img=pygame.image.load("hpbuff.png").convert()
hpbuff_img.set_colorkey(white)
attackbuff_img=pygame.image.load("attackbuff.png").convert()
attackbuff_img.set_colorkey(white)
speedbuff_img=pygame.image.load("speedbuff.png").convert()
speedbuff_img.set_colorkey(white)

playerl=pygame.image.load("charmodelleftx.png").convert()
playerl.set_colorkey(black)
playerr=pygame.image.load("charmodelrightx.png").convert()
playerr.set_colorkey(black)
playeru=pygame.image.load("charmodelbackx.png").convert()
playeru.set_colorkey(black)
playerd=pygame.image.load("charmodelfrontx.png").convert()
playerd.set_colorkey(black)



walkable_tiles_list=['grass']

active_creatures_list=['Time_Player']
active_creatures_time={}

enemy_list=[]

skill_names=['walk','run','weak','strong']
images={'walk':walk_img,'run':run_img,'weak':weak_img,'strong':strong_img}
skill_delay={'walk':0,'run':0,'weak':0,'strong':0}
skill_supposed_delay={'walk':400,'run':1200,'weak':900,'strong':2300}

skull_stats={'HP':220,'MP':30,'A':2,'CD':0,'1':700,'2':1000,'ATT':150}
Time_Player_stats={'HP':700,'MP':500,'ATT':50}
Time_Player_stats['SATT']=Time_Player_stats['ATT']*2+Time_Player_stats['ATT']/2
Time_Player_stats['MAXHP']=Time_Player_stats['HP']
Time_Player_stats['INITHP']=Time_Player_stats['HP']
skull_stats['MAXHP']=skull_stats['HP']
data={'skull':skull_stats,'Time_Player':Time_Player_stats}

sky=pygame.image.load("sky.png").convert()
obstacle_img=pygame.image.load("obstacle.png").convert()
obstacle_img.set_colorkey(white)

skill_clocks={}

skill_selector='walk'
def change_speed(by):
    for i in range(data['skull']['A']):
        data['skull'][str(i+1)]=data['skull'][str(i+1)]/by
    
    
def Obstacle(x,y):
    screen.blit(obstacle_img,(x/grass_img.get_width()*grass_img.get_width(),y/grass_img.get_height()*grass_img.get_height()))
def clicked(x,y,where):
    global d,h,s,a,leveled,switch
    
    if where=="buff":
        
        if pygame.Rect(h,hpbuff_img.get_size()).collidepoint(x,y):
            
            Time_Player_stats['HP']=Time_Player_stats['MAXHP']
            Time_Player_stats['MAXHP']+=Time_Player_stats['MAXHP']/2
            
            leveled=False
            switch=True
            
        if pygame.Rect(a,attackbuff_img.get_size()).collidepoint(x,y):
            Time_Player_stats['ATT']+=Time_Player_stats['ATT']/5
            Time_Player_stats['SATT']=Time_Player_stats['ATT']*2+Time_Player_stats['ATT']/2

            leveled=False
            switch=True
            
        if pygame.Rect(d,dexbuff_img.get_size()).collidepoint(x,y):
            skill_supposed_delay['weak']-=skill_supposed_delay['weak']/3
            skill_supposed_delay['strong']-=skill_supposed_delay['strong']/3

            leveled=False
            switch=True
        if pygame.Rect(s,speedbuff_img.get_size()).collidepoint(x,y):
            skill_supposed_delay['walk']-=skill_supposed_delay['walk']/5
            skill_supposed_delay['run']-=skill_supposed_delay['run']/5
                
            leveled=False
            switch=True
        
        
              
def topontop():
    a=False
    c=0
    
    for i in range(len(enemy_list)):
        for j in range(len(enemy_list)):
            
            if (enemy_list[j].x==enemy_list[i].x and enemy_list[j].y==enemy_list[i].y) and j<>i: #doesn't matter whether tile or not. enemies created equal.
                a=True
                
    for i in range(len(tile_list)):
        for j in range(len(enemy_list)):
            if (enemy_list[j].tilex==tile_list[i].x and enemy_list[j].tiley==tile_list[i].y) and (tile_list[i].type not in walkable_tiles_list):
               a=True
               
    return a
def check_pos():    
    for i in range(len(enemy_list)):
        while topontop() or (enemy_list[i].tilex==time_player.tilex and enemy_list[i].tiley==time_player.tiley):
            
            
            enemy_list[i].reposition()
            
            if not(topontop()) or (enemy_list[i].x<>time_player.x and enemy_list[i].y<>time_player.y):
                break
            
def levelUP():
    global switch,Time_Player_stats,level,leveled,d,h,s,a
    
    if level<>1 and leveled:
        
        switch=False
        d=size[0]/60,size[1]/40
        h=size[0]-(dexbuff_img.get_width()),size[1]/40
        s=size[0]/60,size[1]-(speedbuff_img.get_height())
        a=size[0]-dexbuff_img.get_width(),size[1]-speedbuff_img.get_height()
        screen.blit(dexbuff_img,(d))
        screen.blit(hpbuff_img,(h))
        screen.blit(speedbuff_img,(s))
        screen.blit(attackbuff_img,(a))
        

def delay_motherfucker(name):
    clock=pygame.time.Clock()
    skill_clocks[name]=clock
def final_countdown():    
        for i in range(len(skill_names)):
            if skill_names[i] in skill_clocks:
                images[skill_names[i]].set_alpha(150)
                z=skill_clocks[skill_names[i]].tick()
                skill_delay[skill_names[i]]+=z
                
                if skill_delay[skill_names[i]]>skill_supposed_delay[skill_names[i]]:

                    del skill_clocks[skill_names[i]]
                    skill_delay[skill_names[i]]=0
            elif skill_names[i] not in skill_clocks:
                images[skill_names[i]].set_alpha(255)
                    
def recolour(image,replace,new):
    newimage=image.copy()
    for x in range(image.get_width()):
        for y in range(image.get_height()):
            if image.get_at((x,y))==replace:
                newimage.set_at((x,y),new)
    return newimage
class Enemy:
    def __init__(self,name,x,y,clock,str):
        self.ethereal=False
        self.name=name+str
        self.surname=self.name.replace(str,'')
        self.str=str
        stats=data[self.surname]        
        data[self.name]=stats
        self.HP=data[self.name]['HP']
        self.MP=data[self.name]['MP']
        self.MAXHP=data[self.name]['MAXHP']
        self.dead=False
        self.clock=clock
        self.action=1
        self.direction='down'
        self.image=image(self.direction,self.surname)
        self.x=x/grass_img.get_width()*grass_img.get_width()+grass_img.get_width()/2-self.image.get_width()/2
        self.y=y/grass_img.get_height()*grass_img.get_height()-self.image.get_height()+grass_img.get_height()/2+size[1]/60
        self.tilex=self.x-grass_img.get_width()/2+self.image.get_width()/2
        self.tiley=self.y+self.image.get_height()-grass_img.get_height()/2-size[1]/60
        
    def reposition(self):
        self.x=random.randint(0,size[0]-1)/grass_img.get_width()*grass_img.get_width()+grass_img.get_width()/2-self.image.get_width()/2
        self.y=random.randint(size[1]-grass_img.get_height()*3,size[1]-1)/grass_img.get_height()*grass_img.get_height()-self.image.get_height()+grass_img.get_height()/2+size[1]/60
    def blit(self):
    
        if not(self.dead):
            self.image=image(self.direction,self.surname)
            screen.blit(self.image,(self.x,self.y))        
            
    def define(self):
        if not(self.dead):
            screen.blit(definer_img,(self.x-grass_img.get_width()/2+self.image.get_width()/2,self.y+self.image.get_height()-grass_img.get_height()/2-size[1]/60))    
               
    def hpbar(self):
        if not(self.dead):
            screen.blit(pygame.transform.smoothscale(nohp_img,(nohp_img.get_width()/4,nohp_img.get_height()/2)),(self.x+size[0]/250,self.y-size[1]/200))
            screen.blit(pygame.transform.smoothscale(recolour(recolour(hp_img,(69,160,46),(224,49,49)),(0,63,2),(81,18,19)),((self.HP*hp_img.get_width()/4)/self.MAXHP,hp_img.get_height()/2)),(self.x+size[0]/250,self.y-size[1]/200))

    def move(self):
        if self.action==1: #Chase you
                        global obstacle
                        DONE=False
                        zero=Stalk(0,0,0,0,grass_img.get_width(),grass_img.get_height(),[])

                        
                        for i in range(len(zero.fway(self.tilex,self.tiley))-1):
                            
                            if not((time_player.tilex,time_player.tiley) in zero.fway(self.tilex,self.tiley)):
                                        oldx=self.x
                                        oldy=self.y
                                        self.x=finalfind(self.tilex,self.tiley,time_player.tilex,time_player.tiley,grass_img.get_width(),grass_img.get_height())[0][0]/grass_img.get_width()*grass_img.get_width()+grass_img.get_width()/2-self.image.get_width()/2
                                        self.y=finalfind(self.tilex,self.tiley,time_player.tilex,time_player.tiley,grass_img.get_width(),grass_img.get_height())[0][1]/grass_img.get_height()*grass_img.get_height()-self.image.get_height()+grass_img.get_height()/2+size[1]/60
                                        if oldy>self.y:
                                            self.direction='up'
                                        else:
                                            self.direction='down'
                                        break
                               

                            else:
                                self.action=2
                                
    def calc_tile(self):
        self.tilex=self.x-grass_img.get_width()/2+self.image.get_width()/2
        self.tiley=self.y+self.image.get_height()-grass_img.get_height()/2-size[1]/60
        
    def behavior(self): #The big glossary of shit monstas can do to ya!

        global turn
        
        if turn==self.name:
            if data[self.name]['CD']<=0:
                self.clock=pygame.time.Clock()
                self.action=random.randint(1,data[self.name]['A'])
                data[self.name]['CD']=data[self.name][str(self.action)]
            if self.action<>0:
                if self.surname=='skull':
                    self.clock=pygame.time.Clock()
                    self.action=1
                    data[self.name]['CD']=data[self.name][str(self.action)]
                    


                    self.move()     #Nowhere to chase
                            
                    if self.action==2:
                        if (self.tilex==time_player.tilex and (self.tiley==time_player.tiley+grass_img.get_height() or self.tiley==time_player.tiley-grass_img.get_height())) or (self.tiley==time_player.tiley and (self.tilex==time_player.tilex+grass_img.get_width() or self.tilex==time_player.tilex-grass_img.get_width())):
                            data['Time_Player']['HP']-=data[self.name]['ATT']
                            if self.tiley<time_player.tiley:
                                self.direction='down'
                            elif self.tiley>time_player.tiley:
                                self.direction='up'
                                
                                
                        


                    self.action=0
                       

        
                
            
    def count_time(self):
        global turn
        if turn==self.name:
            if data[self.name]['CD']>0:
               z=self.clock.tick()
               
               data[self.name]['CD']-=z
            
def restart():
    global switch,time_player,player,walkable_tiles_list,active_creatures_list,active_creatures_time,enemy_list,skill_names,images,skill_delay
    global skill_supposed_delay, skull_stats,Time_Player_stats,data,skill_clocks,skill_selector,skull
    global tile_list,find,switch,second_counter,default_time,turn,find_time,skill_number,target_tick,level,leveled,h,d,s,a
    
    leveled=False
    level+=1
    target_tick=0
    second_counter=0
    switch=True
    find=True
    find_time=True
    tock=0
    default_time=4
    turn='Time_Player'
    skill_number=1
    space_toggled=False

    d=size[0]/60,size[1]/40
    h=size[0]-(dexbuff_img.get_width()),size[1]/40
    s=size[0]/60,size[1]-(speedbuff_img.get_height())
    a=size[0]-dexbuff_img.get_width(),size[1]-speedbuff_img.get_height()
    
    
    
    
    Time_Player_stats['HP']=Time_Player_stats['MAXHP']
    time_player.dead=False
    walkable_tiles_list=['grass']
    time_player.direction='down'


    active_creatures_list=['Time_Player']
    active_creatures_time={}

    enemy_list=[]

    skill_delay={'walk':0,'run':0,'weak':0,'strong':0}
    
    
    skill_clocks={}

    skill_selector='walk'
    
    
    for i in range(level):
        x=random.randint(0,size[0]-1)
        y=random.randint(size[1]-grass_img.get_height()*3,size[1]-1)
        
        skull=Enemy('skull',x,y,pygame.time.Clock(),str(i))
        enemy_list.append(skull)
        active_creatures_list.append(skull.name)
    

class Tile:
    def __init__(self,type,x,y):
        self.type=type
        self.x=x
        self.y=y
        one=random.randint(0,1)
        two=random.randint(0,1)
            
        if one==0:
                self.one=False
        else:
                self.one=True
        if two==0:
                self.two=False
        else:
                self.two=True
        
        a=random.randint(0,1)
        if a>0:
                self.img=grass_img
        else:
                self.img=grass2_img    
    def blit(self):
        if self.type=='grass':
            screen.blit(pygame.transform.flip(self.img,self.one,self.two), (self.x,self.y))
        elif self.type=='obstacle':
            Obstacle(self.x,self.y)




def image(direction,who):
    
    
    if (who=='player') or (who=='time_player'):
        
        if direction=='up':
            return playeru
        elif direction=='down':
            return playerd
        elif direction=='left':
            return playerl
        elif direction=='right':
            return playerr
    if who=='skull':
        if direction=='up':
            return skullback_img
        elif direction=='down':
            return skullfront_img
                
class Player:
    def __init__(self,x,y):
        
        self.direction='down'
        self.img=image(self.direction,"player")
        self.x=x/grass_img.get_width()*grass_img.get_width()+grass_img.get_width()/2-self.img.get_width()/2
        self.y=y/grass_img.get_height()*grass_img.get_height()-self.img.get_height()+grass_img.get_height()/2+size[1]/60
        
    def blit(self):
        
        self.img=image(self.direction,"player")
        screen.blit(self.img,(self.x,self.y-grass_img.get_height()/4))
        
    def walk(self,flag):
          
        if flag==1:
            for i in tile_list:
                if i.x==self.tilex and i.y==(self.tiley-grass_img.get_height()) and i.type in walkable_tiles_list:
                    self.y-=grass_img.get_height()
                    self.direction='up'
                    break
        elif flag==2:
            for i in tile_list:
                if i.x==self.tilex and i.y==(self.tiley+grass_img.get_height()) and i.type in walkable_tiles_list:
                    self.y+=grass_img.get_height()
                    self.direction='down'
                    break

        elif flag==3:
            for i in tile_list:
                if i.x==(self.tilex-grass_img.get_width()) and i.y==self.tiley and i.type in walkable_tiles_list:
                    self.x-=grass_img.get_width()
                    self.direction='left'
                    break
        elif flag==4:
            for i in tile_list:
                if i.x==(self.tilex+grass_img.get_width()) and i.y==self.tiley and i.type in walkable_tiles_list:
                    self.x+=grass_img.get_width()
                    self.direction='right'
                    break
        flag=0
    def calc_tile(self,found):
        global find
        if found==True:
            self.tilex=self.x-grass_img.get_width()/2+self.img.get_width()/2
            self.tiley=self.y+self.img.get_height()-grass_img.get_height()/2-size[1]/60
            
            for i in range (len(tile_list)):
                if (self.tilex==tile_list[i].x) and (self.tiley==tile_list[i].y):
                    
                    find=False
                    

def sound(path):
    s=pygame.mixer.Sound(path)
    s.play()
    
class Time_Player:
    def __init__(self,x,y):
        self.direction='down'
        self.img=image(self.direction,"time_player")
        self.tilex=x/grass_img.get_width()*grass_img.get_width()
        self.tiley=y/grass_img.get_height()*grass_img.get_height()
        self.x=x/grass_img.get_width()*grass_img.get_width()+grass_img.get_width()/2-self.img.get_width()/2
        self.y=y/grass_img.get_height()*grass_img.get_height()-self.img.get_height()+grass_img.get_height()/2+size[1]/60
        self.dead=False
    def blit(self):
        self.img=image(self.direction,"time_player")
        screen.blit(self.img,(self.x,self.y-grass_img.get_height()/4))
    def turns(self):
        global turn,second_counter
        
        if active_creatures_time[turn]==second_counter:
            if active_creatures_list.index(turn)+1==len(active_creatures_list):
                turn=active_creatures_list[0]
            else:
                turn=active_creatures_list[active_creatures_list.index(turn)+1]
            second_counter=1
    def calc_tile(self,found_time):
        global find_time
        if found_time:
            self.tilex=self.x-grass_img.get_width()/2+self.img.get_width()/2
            self.tiley=self.y+self.img.get_height()-grass_img.get_height()/2-size[1]/60
            
            for i in range (len(tile_list)):
                if (self.tilex==tile_list[i].x) and (self.tiley==tile_list[i].y):
                    find_time=False

    def walk(self,flag,name):
        if skill_delay[name]==0 and turn=='Time_Player':
            if name=='walk':               
                if flag==1:
                    allowed=True
                    
                    for i in range(len(enemy_list)):
                        if self.tilex==enemy_list[i].tilex and self.tiley==enemy_list[i].tiley+grass_img.get_height():
                            allowed=False
                            break
                        else:
                            allowed=True
                    if allowed:
                        for i in tile_list:
                                if (i.x==self.tilex and i.y==(self.tiley-grass_img.get_height())) and i.type in walkable_tiles_list:
                                    self.y-=grass_img.get_height()
                                    delay_motherfucker(name)
                                    break
                    
                    self.direction='up'                
                                    
                                    
                                    
                    
                elif flag==2:
                    allowed=True
    
                    for i in range(len(enemy_list)):
                        if self.tilex==enemy_list[i].tilex and self.tiley==enemy_list[i].tiley-grass_img.get_height():
                            allowed=False
                            break
                        else:
                            allowed=True
                    if allowed:
                        for i in tile_list:
                                if i.x==self.tilex and i.y==(self.tiley+grass_img.get_height()) and i.type in walkable_tiles_list:
                                    self.y+=grass_img.get_height()
                                    delay_motherfucker(name)
                                    
                                    break
                    self.direction='down'

                elif flag==3:
                    allowed=True

                    for i in range(len(enemy_list)):
                        if self.tilex==enemy_list[i].tilex+grass_img.get_width() and self.tiley==enemy_list[i].tiley:
                            allowed=False
                            break
                        else:
                            allowed=True
                    if allowed:
                        for i in tile_list:
                                if i.x==(self.tilex-grass_img.get_width()) and i.y==self.tiley and i.type in walkable_tiles_list:
                                    self.x-=grass_img.get_width()
                                    delay_motherfucker(name)
                                    
                                    break
                    self.direction='left'
                            
                elif flag==4:
                    allowed=True
                    

                    for i in range(len(enemy_list)):
                        if self.tilex==enemy_list[i].tilex-grass_img.get_width() and self.tiley==enemy_list[i].tiley:
                            allowed=False
                            break
                        else:
                            allowed=True
                    if allowed:
                        for i in tile_list:
                                if i.x==(self.tilex+grass_img.get_width()) and i.y==self.tiley and i.type in walkable_tiles_list:
                                    self.x+=grass_img.get_width()
                                    delay_motherfucker(name)
                                    
                                    break
                    self.direction='right'
                    
            elif name=='run':
                if flag==1:
                    allowed=True
                    
                    for i in range(len(enemy_list)):
                        if self.tilex==enemy_list[i].tilex and self.tiley==enemy_list[i].tiley+grass_img.get_height()*2:
                            allowed=False
                            break
                        else:
                            allowed=True
                    if allowed:
                        for i in tile_list:
                                if i.x==self.tilex and i.y==(self.tiley-grass_img.get_height()*2) and i.type in walkable_tiles_list:
                                    self.y-=grass_img.get_height()*2
                                    delay_motherfucker(name)
                                    
                                    break
                    self.direction='up'
                elif flag==2:       
                    allowed=True
                    
                    for i in range(len(enemy_list)):
                        if self.tilex==enemy_list[i].tilex and self.tiley==enemy_list[i].tiley-grass_img.get_height()*2:
                            allowed=False
                            break
                        else:
                            allowed=True
                    if allowed:
                        for i in tile_list:
                                if i.x==self.tilex and i.y==(self.tiley+grass_img.get_height()*2) and i.type in walkable_tiles_list:
                                    self.y+=grass_img.get_height()*2
                                    delay_motherfucker(name)
                                    
                                    break
                    self.direction='down'

                elif flag==3:
                    allowed=True
                    
                    for i in range(len(enemy_list)):
                        if self.tilex==enemy_list[i].tilex+grass_img.get_width()*2 and self.tiley==enemy_list[i].tiley:
                            allowed=False
                            break
                        else:
                            allowed=True
                    if allowed:
                        for i in tile_list:
                                if i.x==(self.tilex-grass_img.get_width()*2) and i.y==self.tiley and i.type in walkable_tiles_list:
                                    self.x-=grass_img.get_width()*2
                                    delay_motherfucker(name)
                                    
                                    break
                    self.direction='left'
                elif flag==4:
                    allowed=True
                    for i in range(len(enemy_list)):
                        if self.tilex==enemy_list[i].tilex-grass_img.get_width()*2 and self.tiley==enemy_list[i].tiley:
                            allowed=False
                            break
                        else:
                            allowed=True
                    if allowed:
                        for i in tile_list:
                                if i.x==(self.tilex+grass_img.get_width()*2) and i.y==self.tiley and i.type in walkable_tiles_list:
                                    self.x+=grass_img.get_width()*2
                                    delay_motherfucker(name)
                                    
                                    break
                    self.direction='right'
            elif name=='weak':
                if flag==1:
                    for i in range(len(enemy_list)):
                        if enemy_list[i].tilex==self.tilex and enemy_list[i].tiley==self.tiley-grass_img.get_height():
                            enemy_list[i].HP-=data['Time_Player']['ATT']
                            
                            
                            
                            
                        delay_motherfucker(name)
                        self.direction='up'
                        sound("cut.wav")
                        
                        
                elif flag==2:
                    for i in range(len(enemy_list)):
                        if enemy_list[i].tilex==self.tilex and enemy_list[i].tiley==self.tiley+grass_img.get_height():
                            enemy_list[i].HP-=data['Time_Player']['ATT']

                        delay_motherfucker(name)
                        sound("cut.wav")
                        self.direction='down'
                                                    
                elif flag==3:
                    for i in range(len(enemy_list)):
                        if enemy_list[i].tilex==self.tilex-grass_img.get_width() and enemy_list[i].tiley==self.tiley:
                            enemy_list[i].HP-=data['Time_Player']['ATT']
                        delay_motherfucker(name)
                        sound("cut.wav")
                        self.direction='left'
                elif flag==4:
                    for i in range(len(enemy_list)):
                        if enemy_list[i].tilex==self.tilex+grass_img.get_width() and enemy_list[i].tiley==self.tiley:
                            enemy_list[i].HP-=data['Time_Player']['ATT']

                        delay_motherfucker(name)
                        sound("cut.wav")
                        self.direction='right'
                            
            elif name=='strong':
                if flag==1:
                    for i in range(len(enemy_list)):
                        if enemy_list[i].tilex==self.tilex and enemy_list[i].tiley==self.tiley-grass_img.get_height():
                            enemy_list[i].HP-=data['Time_Player']['SATT']

                        delay_motherfucker(name)
                        sound("sword.wav")
                        self.direction='up'
                        
                elif flag==2:
                    for i in range(len(enemy_list)):
                        if enemy_list[i].tilex==self.tilex and enemy_list[i].tiley==self.tiley+grass_img.get_height():
                            enemy_list[i].HP-=data['Time_Player']['SATT']

                        delay_motherfucker(name)
                        sound("sword.wav")
                        self.direction='down'
                        
                elif flag==3:
                    for i in range(len(enemy_list)):
                        if enemy_list[i].tilex==self.tilex-grass_img.get_width() and enemy_list[i].tiley==self.tiley:
                            enemy_list[i].HP-=data['Time_Player']['SATT']

                        delay_motherfucker(name)
                        sound("sword.wav")
                        self.direction='left'
                        
                elif flag==4:
                    for i in range(len(enemy_list)):
                        if enemy_list[i].tilex==self.tilex+grass_img.get_width() and enemy_list[i].tiley==self.tiley:
                            enemy_list[i].HP-=data['Time_Player']['SATT']

                        delay_motherfucker(name)
                        sound("sword.wav")
                        self.direction='right'
                        
            
class Text:
    def __init__(self,x,y,font,size,words,AA,colour):
        self.x=x
        self.y=y
        self.font=font
        self.size=size
        self.words=words
        self.AA=AA
        self.colour=colour
    def create(self):
        self.Font = pygame.font.SysFont(self.font, self.size)
        self.text =self.Font.render(self.words, self.AA, self.colour)
    def blit(self):
        screen.blit(self.text, (self.x, self.y))

x=0
y=size[1]-grass_img.get_height()*6

global tile_list,find,switch,second_counter,default_time,turn,find_time,skill_number,target_tick,level,leveled,h,d,s,a
d=size[0]/60,size[1]/40
h=size[0]-(dexbuff_img.get_width()),size[1]/40
s=size[0]/60,size[1]-(speedbuff_img.get_height())
a=size[0]-dexbuff_img.get_width(),size[1]-speedbuff_img.get_height()
leveled=False
level=0
target_tick=0
tile_list=[]
second_counter=0
switch=False
find=True
find_time=True
tock=0
default_time=4
turn='Time_Player'
skill_number=1
space_toggled=False
by=1

time_player=Time_Player(300,500)
player=Player(300,500)

for i in range(1000):
    random_obst=random.randint(0,100)
    if random_obst>90:
        if x==time_player.tilex and y==time_player.tiley:
           pass
        else:
            tile=Tile('obstacle',x,y)
            tile_list.append(tile)
    if random_obst<=90 or (x==time_player.tilex and y==time_player.tiley):
        tile=Tile('grass',x,y)
        tile_list.append(tile)
    x+=grass_img.get_width()
    if x>=size[0]:
        x=0
        y+=grass_img.get_height()
        
    if y>=size[1]:
        break
def four_way(place):
    return [(place[0],place[1]-grass_img.get_height()),(place[0],place[1]+grass_img.get_height()),(place[0]-grass_img.get_width(),place[1]),(place[0]+grass_img.get_width(),place[1])]
    
def find_path(desired_list):
    pass





def create_skill_bar():
    distance_x=size[0]-size[0]/60*len(skill_names)-walk_img.get_width()*len(skill_names)
    distance_y=size[1]-walk_img.get_height()-size[1]/40

    for i in range(len(skill_names)):
        screen.blit(images[skill_names[i]],(distance_x,distance_y))
        if skill_selector==skill_names[i]:
            screen.blit(skill_select_img,(distance_x,distance_y))
        distance_x+=size[0]/60+walk_img.get_width()
        
        
def allow_time():
    for i in range(len(active_creatures_list)):
        active_creatures_time[active_creatures_list[i]]=default_time



                
class Stalk:
    def __init__(self,x,y,x2,y2,w,h,walk):
        self.x=x
        self.y=y
        self.x2=x2
        self.y2=y2
        self.w = w
        self.h = h
        self.found = False
        self.temp_parent=int
        self.openlist=[((self.x,self.y),(self.x,self.y))]
        self.closedlist={}
        self.twodelete=[]
        self.pathlist=[]
        self.walk=walk
        self.done=False
        self.dead=False
        
    def fway(self,a,b):
        return ((a,b-self.h),(a,b+self.h),(a+self.w,b),(a-self.w,b),(a,b))
        
    def find(self,a,b):
        
        for i in range(4):
            if (((self.fway(a,b)[i],self.fway(a,b)[4]) not in self.openlist) and (self.fway(a,b)[i] in self.walk)):
                self.openlist.append((self.fway(a,b)[i],self.fway(a,b)[4]))
            
        
        
            if self.fway(a,b)[i]==(self.x2,self.y2):
                    self.found = True
                    
                
                    if self.fway(a,b)[i] not in self.pathlist:
                        self.pathlist.append((self.fway(a,b)[i]))
                        if (a,b) not in self.pathlist:
                            self.pathlist.append((a,b))
                        self.temp_parent=(a,b)
                
    def chartpath(self,do):
        
        if do and not(self.done):
            while self.pathlist[-1]<>(self.x,self.y):
                self.makeme()
            self.pathlist=self.pathlist[::-1]
            
            self.done=True
            
    
    def makeme(self):
        for i in self.closedlist:
            if i==self.temp_parent:
                self.pathlist.append(self.closedlist[i])
                self.temp_parent=self.closedlist[i]
    def chart(self):
        if not(self.found):
            for i in range(len(self.openlist)):
                self.find(self.openlist[i][0][0],self.openlist[i][0][1])
                self.closedlist[(self.openlist[i][0][0],self.openlist[i][0][1])]=(self.openlist[i][1][0],self.openlist[i][1][1])
        for i in range(len(self.openlist)):
            if self.openlist[i][0] in self.closedlist:
                self.twodelete.append(self.openlist[i])
        for i in range(len(self.twodelete)):
            del self.openlist[self.openlist.index(self.twodelete[i])]

        self.twodelete=[]

        self.chartpath(self.found)
    
        for i in range(len(self.pathlist)):
            for j in range(len(self.pathlist)):
                if self.pathlist[i]==self.pathlist[j] and j<>i:
                    del self.pathlist[i]
                    break
            break
        for i in range(len(self.pathlist)):
            if self.pathlist[i]==(self.x,self.y):
                del self.pathlist[i]
                
                break
        if len(self.pathlist)==0:
            pass
        elif self.done and not (self.pathlist is None):
            return self.pathlist
    
    def blit(self):
        for i in range(len(self.walk)):
            pygame.draw.rect(screen,(0,0,0),[self.walk[i][0],self.walk[i][1],self.w,self.h])
        for i in range(len(self.pathlist)):
            pygame.draw.rect(screen,(255,255,255),[self.pathlist[i][0],self.pathlist[i][1],self.w,self.h])
            
    
def count_time():
    global tock,second_counter,by
    names=[]
    for i in range(len(enemy_list)):
        names.append(enemy_list[i].name)
    if turn in names:
        tock+=time_counter.tick()*by
    else:
        tock+=time_counter.tick()
    if tock>=1000:
        
        tock=0
        second_counter+=1
def visual_counter():
    if second_counter<>default_time:
        text=Text(size[0]/2,size[1]/40,"Gautami",35,str(second_counter),True,white)
    else:
        text=Text(size[0]/2,size[1]/40,"Gautami",35,str(second_counter-1),False,white)
    
    text.create()
    text.blit()
        
def HPBARS(coords):
    screen.blit(pygame.transform.smoothscale(nohp_img,((Time_Player_stats['MAXHP']*hp_img.get_width())/Time_Player_stats['INITHP'],hp_img.get_height())),coords)
    screen.blit(pygame.transform.smoothscale(hp_img,(Time_Player_stats['HP']*Time_Player_stats['MAXHP']*hp_img.get_width()/Time_Player_stats['INITHP']/Time_Player_stats['MAXHP'],hp_img.get_height())),coords)
    for i in range(len(enemy_list)):
        enemy_list[i].hpbar()
         
    
def background_blit():
    screen.fill(skyblue)
    for i in range(len(tile_list)):
        tile_list[i].blit()
    screen.blit(pygame.transform.smoothscale(sky,(size[0],sky.get_height())),(0,0))
    levelUP()

    
    
def player_blits():
    player.calc_tile(find)
    player.blit()
    levelUP()
def Time_Player_blits():
    count_time()
    time_player.turns()
    time_player.calc_tile(find_time)
    define("time_player")    
    define("enemy")
    life_check()
    time_player.blit()
    HPBARS((size[0]/60,size[1]/40))
    create_skill_bar()
    visual_counter()
    final_countdown()
    
    

def define(whom):
    if whom=="enemy":
        for i in range(len(enemy_list)):
            enemy_list[i].define()
    elif whom=="time_player":
        screen.blit(recolour(definer_img,red,black),(time_player.x-grass_img.get_width()/2+time_player.img.get_width()/2,time_player.y+time_player.img.get_height()-grass_img.get_height()/2-size[1]/60))

def life_check():
    death=-1
    dead=0
    for i in range(len(enemy_list)):
        if enemy_list[i].HP<=0:
            enemy_list[i].dead=True
            dead=active_creatures_list.index(enemy_list[i].name)
            death=i
        
        enemy_list[i].blit()
        enemy_list[i].behavior()
        enemy_list[i].count_time()
        enemy_list[i].calc_tile()
        
    if death>-1:
        del enemy_list[death]
        death=False
    if dead<>0:
        del active_creatures_list[dead]
        dead=0
        
    if data['Time_Player']['HP']<=0:
        time_player.dead=True

    if time_player.dead:
        world_restart()
        
    if len(enemy_list)==0:
        global leveled
        world_restart()
        leveled=True
        
        

    
    
    
    
def update_time_creatures():
    allow_time()
    





def SPACE(determinator):
    global skill_selector
    pygame.event.pump()
    key=pygame.key.get_pressed()
                    
    if determinator=='move':
        if (key[pygame.K_SPACE]):
            skill_selector='run'
        elif not(key[pygame.K_SPACE]):
            skill_selector='walk'
    elif determinator=='attack':
        if (key[pygame.K_SPACE]):
            skill_selector='strong'
        elif not(key[pygame.K_SPACE]):
            skill_selector='weak'
              
              


def world_restart():
    restart()
    
def finalfind(x,y,x2,y2,w,h):
    
    
    walkablelist=[]
    delete=[]
    current=1000
    
    for i in range(len(tile_list)):
        if not(tile_list[i].type=='obstacle'):
            walkablelist.append((tile_list[i].x,tile_list[i].y))
    for i in range(len(enemy_list)):
        if (enemy_list[i].tilex,enemy_list[i].tiley) in walkablelist:
            delete.append((enemy_list[i].tilex,enemy_list[i].tiley))
    for i in range(len(delete)):
        del walkablelist[walkablelist.index(delete[i])]
        
        
            
    ktar=0
    
    
    path=[]
    zero=Stalk(0,0,0,0,grass_img.get_width(),grass_img.get_height(),walkablelist)
    
    for i in range(len(zero.fway(x2,y2))-1):
        
        one=Stalk(x,y,zero.fway(x2,y2)[i][0],zero.fway(x2,y2)[i][1],w,h,walkablelist)
        
        while not(one.dead):
            
            if not(one.chart() is None) and not(one.dead):
                
               if (zero.fway(x2,y2)[i][0],zero.fway(x2,y2)[i][1]) in walkablelist: 
                    if len(one.pathlist)<current:
                        current=len(one.pathlist)
                        path=one.pathlist
                    one.dead=True
                    
               elif not((zero.fway(x2,y2)[i][0],zero.fway(x2,y2)[i][1]) in walkablelist):
                   break
            else:
                 if ktar>200:
                     break

                 
                 
            ktar+=1
            
    
    
    
        
        
    if len(path) == 0:
        path=[(x,y)]

    return path
    
by=2
change_speed(by)   


# -------- Main Program Loop -----------
while done == False:
    for event in pygame.event.get(): 
        if event.type == pygame.QUIT: 
            done = True 
        if not(switch):

            if event.type==pygame.MOUSEBUTTONDOWN:
                x,y= event.pos
                clicked(x,y,"buff")
                
            if event.type==pygame.KEYDOWN:
                    
                    if event.key==pygame.K_w:
                        player.walk(1)
                        find=True
                    elif event.key==pygame.K_s:
                        player.walk(2)
                        find=True
                        
                    elif event.key==pygame.K_a:
                        player.walk(3)
                        find=True
            
                    elif event.key==pygame.K_d:
                        player.walk(4)
                        find=True
        elif switch:

            if event.type==pygame.KEYDOWN:
                    if event.key==pygame.K_w:
                        SPACE('move')
                        time_player.walk(1,skill_selector)
                        find_time=True
                        
                    elif event.key==pygame.K_s:
                        SPACE('move')
                        time_player.walk(2,skill_selector)
                        find_time=True
                        
                    elif event.key==pygame.K_a:
                        SPACE('move')
                        time_player.walk(3,skill_selector)
                        find_time=True
        
                    elif event.key==pygame.K_d:
                        SPACE('move')
                        time_player.walk(4,skill_selector)
                        find_time=True
        
                    elif event.key==pygame.K_1:
                        skill_selector='walk'
                        if by<2:
                            by=2
                            change_speed(by)

                    elif event.key==pygame.K_2:
                        skill_selector='run'
                        if by>1:
                            by=0.5
                            change_speed(by)
                            by=1
                            

                    elif event.key==pygame.K_3:
                        skill_selector='weak'
                    elif event.key==pygame.K_4:
                        skill_selector='strong'

                    elif event.key==pygame.K_r:
                        world_restart()
                        leveled=True
                        
                    elif event.key==pygame.K_UP:
                        SPACE('attack')
                        time_player.walk(1,skill_selector)
                        
                    elif event.key==pygame.K_DOWN:
                        SPACE('attack')
                        time_player.walk(2,skill_selector)

                    elif event.key==pygame.K_LEFT:
                        SPACE('attack')
                        time_player.walk(3,skill_selector)
                        
                    elif event.key==pygame.K_RIGHT:
                        SPACE('attack')
                        time_player.walk(4,skill_selector)
                        
                    
                        
                    
                        
    
                        
        if event.type==pygame.KEYDOWN:
                if event.key==pygame.K_RETURN:
                     switch=not(switch)
                elif event.key==pygame.K_F1:
                     done=True

    background_blit()
    update_time_creatures()
    check_pos()
    
    
    if not(switch):
        player_blits()
    else:
        Time_Player_blits()

    pygame.display.flip()
    
    clock.tick(FPS)

pygame.quit()



#Code 60x40.
#flags= 1up,2down,3left,4right
